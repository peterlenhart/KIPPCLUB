<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>FAIRY KIPP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Montserrat:wght@500;700&display=swap" rel="stylesheet"/>

  <style>
    :root{
      --fk-blue: rgb(0, 101, 171);
      --fk-violet: rgb(170, 0, 120);
      --fk-green: rgb(59, 165, 43);
      --fk-orange: rgb(242, 150, 0);

      --fk-bg: #000;
      --fk-text: #f5f5f5;
      --fk-muted: #bdbdbd;
      --fk-border: rgba(255,255,255,0.14);
    }

    *{ box-sizing:border-box; margin:0; padding:0; }

    body{
      background: var(--fk-bg);
      color: var(--fk-text);
      font-family:"Montserrat", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:stretch;
      padding: 14px 14px 18px;
    }

    /* EIN Screen, kein “Fernseher im Fernseher” */
    .app{
      width:100%;
      max-width:520px;
      min-height: calc(100vh - 32px);
      display:flex;
      flex-direction:column;
      justify-content:space-between; /* nutzt Höhe */
      gap: 14px;
    }

    header{
      text-align:center;
      padding-top: 4px;
    }

    .logo-line{
      display:inline-flex;
      align-items:baseline;
      gap:8px;
    }
    .logo-fairy{
      font-family:"Pacifico", cursive;
      font-size:2.05rem;
      letter-spacing:0.04em;
      color: var(--fk-orange);
      text-shadow: 0 0 10px rgba(242,150,0,0.7);
    }
    .logo-kipp{
      font-weight:700;
      font-size:1.50rem;
      letter-spacing:0.22em;
      color: var(--fk-blue);
      text-transform:uppercase;
    }
    .tagline{
      margin-top:6px;
      font-size:0.88rem;
      color: var(--fk-muted);
      letter-spacing:0.02em;
    }

    .center{
      display:flex;
      flex-direction:column;
      gap: 14px;
      flex: 1;
      justify-content:flex-start;
      padding-top: 6px;
    }

    .btn-row{
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
    }

    button{
      border:none;
      cursor:pointer;
      font-family:inherit;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }

    .btn-main{
      min-width: 190px;
      padding: 12px 18px;
      border-radius: 12px;
      font-size: 1.05rem;
      font-weight: 900;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      background: var(--fk-orange);
      color:#101010;
      box-shadow: 0 0 16px rgba(242,150,0,0.55);
    }
    .btn-main:active{ transform: translateY(1px) scale(0.99); filter:brightness(0.95); }

    .btn-yes, .btn-no{
      min-width: 168px;
      padding: 11px 14px;
      border-radius: 12px;
      font-size: 0.95rem;
      font-weight: 900;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color:#fff;
    }
    .btn-yes{ background: var(--fk-blue); box-shadow:0 0 14px rgba(0,101,171,0.45); }
    .btn-no { background: rgba(255,255,255,0.10); border:1px solid var(--fk-border); }

    .btn-yes:active, .btn-no:active{ transform: translateY(1px) scale(0.99); filter:brightness(0.95); }

    /* Text frei auf der Seite – ohne Box */
    .story{
      width:100%;
      padding: 6px 2px;
      text-align:center;
      line-height: 1.65;
      font-size: 1.45rem;
      font-weight: 700;
      min-height: 160px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .story.muted{
      color: var(--fk-muted);
      font-style: italic;
      font-size: 1.05rem;
      font-weight: 600;
    }

    .indicator{
      text-align:center;
      font-size: 0.9rem;
      color: var(--fk-muted);
      letter-spacing:0.08em;
      text-transform: uppercase;
      min-height: 1.2em;
    }
    .indicator strong{
      color: var(--fk-violet);
      font-weight:900;
    }

    /* Footer immer unten, Score in der Mitte */
    .footer{
      display:flex;
      flex-direction:column;
      gap: 10px;
      padding-top: 8px;
    }

    .scoreline{
      display:flex;
      justify-content:center;
      align-items:center;
      gap: 10px;
      font-size: 2.2rem;
      font-weight: 900;
      letter-spacing: 0.02em;
      padding: 2px 0;
    }

    .bottom{
      display:flex;
      justify-content:space-between;
      gap:12px;
      font-size: 0.95rem;
    }
    .bottom button{
      background: transparent;
      color: var(--fk-muted);
      text-decoration: underline;
      padding: 10px 6px;
      border-radius: 10px;
    }
    .bottom button:active{
      color:#fff;
      background: rgba(255,255,255,0.06);
      text-decoration:none;
    }

    /* Bestätigungs-Overlay (klein, simpel) */
    .confirm{
      position: fixed;
      inset:0;
      display:none;
      align-items:flex-end;
      justify-content:center;
      background: rgba(0,0,0,0.55);
      z-index: 50;
      padding: 0 14px 18px;
    }
    .confirm-card{
      width:100%;
      max-width: 520px;
      border-radius: 14px;
      border:1px solid var(--fk-border);
      background: rgba(20,20,20,0.96);
      padding: 12px;
    }
    .confirm-title{
      text-align:center;
      font-size:0.9rem;
      color: var(--fk-muted);
      letter-spacing:0.10em;
      text-transform: uppercase;
      margin-bottom: 10px;
    }
    .confirm-row{
      display:flex;
      justify-content:center;
      gap:12px;
    }
    .mini{
      width:56px;
      height:56px;
      border-radius: 12px;
      font-size: 1.6rem;
      font-weight: 900;
      display:flex;
      align-items:center;
      justify-content:center;
      border:1px solid var(--fk-border);
      background: rgba(255,255,255,0.06);
      color:#fff;
    }
    .mini.ok{ border-color: rgba(59,165,43,0.8); }
    .mini.no{ border-color: rgba(255,107,129,0.85); }
    .mini:active{ transform: translateY(1px) scale(0.99); filter:brightness(0.95); }

    .locked{
      opacity: 0.45;
      pointer-events: none;
      filter: grayscale(0.2);
    }
  </style>
</head>

<body>
  <div class="app">

    <header>
      <div class="logo-line">
        <span class="logo-fairy">Fairy</span>
        <span class="logo-kipp">KIPP</span>
      </div>
      <div class="tagline">Unendlich viele KIPP-Geschichten</div>
    </header>

    <div class="center">
      <div class="btn-row">
        <button id="fairy-btn" class="btn-main">FAIRY</button>
      </div>

      <div id="story" class="story muted" title="Tippe hier oder auf WEITER für das nächste Element">
        Tippe auf <strong>FAIRY</strong>, um eine neue Fairy zu starten.
      </div>

      <div id="indicator" class="indicator"></div>

      <div class="btn-row">
        <button id="btn-erkippt" class="btn-yes">FAIRY ERKIPPT</button>
        <button id="btn-nicht" class="btn-no">NICHT ERKIPPT</button>
      </div>
    </div>

    <div class="footer">
      <div class="scoreline">
        <span id="score">0</span>
      </div>

      <div class="bottom">
        <button id="newgame">Neues Spiel</button>
        <button id="home">Zur Startseite</button>
      </div>
    </div>
  </div>

  <!-- Bestätigung -->
  <div id="confirm" class="confirm">
    <div class="confirm-card">
      <div class="confirm-title">FAIRY ERKIPPT bestätigen?</div>
      <div class="confirm-row">
        <button id="confirm-ok" class="mini ok" aria-label="Bestätigen">✓</button>
        <button id="confirm-no" class="mini no" aria-label="Abbrechen">✕</button>
      </div>
    </div>
  </div>

  <script>
    // -----------------------------
    // Konfiguration
    // -----------------------------
    const OPENAI_CHAT_URL = "https://api.openai.com/v1/chat/completions";
    const OPENAI_MODEL = "gpt-4o-mini";
    const APIKEY_STORAGE_KEY = "fairykipp_openai_key";

    const motifsData = [
      { key: "Wasserball",  article: "der",  noun: "Wasserball"  },
      { key: "Auto",        article: "das",  noun: "Auto"        },
      { key: "Farbfleck",   article: "der",  noun: "Farbfleck"   },
      { key: "Buch",        article: "das",  noun: "Buch"        },
      { key: "Gießkanne",   article: "die",  noun: "Gießkanne"   },
      { key: "Kerze",       article: "die",  noun: "Kerze"       },
      { key: "Blume",       article: "die",  noun: "Blume"       },
      { key: "Fisch",       article: "der",  noun: "Fisch"       },
      { key: "Schmetterling", article: "der", noun: "Schmetterling" },
      { key: "Schuh",       article: "der",  noun: "Schuh"       },
      { key: "Tasse",       article: "die",  noun: "Tasse"       },
      { key: "T-Shirt",     article: "das",  noun: "T-Shirt"     }
    ];

    const colorsData = ["grüne", "blaue", "violette", "orangefarbene"];

    const motifVerbBase = {
      Wasserball: ["platschte","plumpste","spritzte","hüpfte","polterte","ploppte"],
      Auto: ["brummte","knatterte","röhrte","tuckerte","schnurrte","hupte","quietschte","dröhnte","heulte","fauchte"],
      Farbfleck: ["tropfte","kleckste","spritzte","schmierte","kleckerte","schmatzte"],
      Buch: ["raschelte","blätterte","murmelte","seufzte","flüsterte","knisterte","wisperte","brummte","klappte"],
      Gießkanne: ["plätscherte","tropfte","gluckerte","schwappte","gluckste","schwallte","gurgelte"],
      Kerze: ["flackerte","knisterte","zischte","glomm","flüsterte","seufzte","hauchte"],
      Blume: ["flüsterte","hauchte","seufzte","wisperte","raschelte","murmelte","säuselte","flötete"],
      Fisch: ["blubberte","gluckerte","sprudelte","murmelte","schmatzte","zischte","schlürfte","schwapperte","gluckste"],
      Schmetterling: ["flüsterte","wisperte","hauchte","seufzte","säuselte","murmelte","kicherte","trillierte","zirpte"],
      Schuh: ["quietschte","klackte","schlurfte","knirschte","tappte","stapfte","polterte","scharrte","knarzte"],
      Tasse: ["klirrte","klimperte","klackte","knackte","zitterte","murmelte","summte","brummte","seufzte"],
      "T-Shirt": ["raschelte","flatterte","seufzte","wisperte","knisterte","murmelte","hauchte","säuselte"]
    };

    // -----------------------------
    // UI
    // -----------------------------
    const fairyBtn = document.getElementById("fairy-btn");
    const storyEl = document.getElementById("story");
    const indicatorEl = document.getElementById("indicator");

    const btnErkippt = document.getElementById("btn-erkippt");
    const btnNicht = document.getElementById("btn-nicht");

    const scoreEl = document.getElementById("score");

    const newgameBtn = document.getElementById("newgame");
    const homeBtn = document.getElementById("home");

    const confirmOverlay = document.getElementById("confirm");
    const confirmOk = document.getElementById("confirm-ok");
    const confirmNo = document.getElementById("confirm-no");

    // -----------------------------
    // Spielzustand
    // -----------------------------
    let apiKey = null;

    let unusedMotifs = [];
    let unusedVerbsByMotif = {};

    let currentMotif = null;
    let currentVerb = null;
    let currentColor = null;

    let chunks = [];           // variable Anzahl (Nomen-Cuts + Schluss-Tail)
    let chunkIndex = 0;

    let score = 0;
    let attempts = 0;
    const maxAttempts = 6;

    // -----------------------------
    // Helpers
    // -----------------------------
    function shuffleArray(arr){
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function escapeHtml(s){
      return String(s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function initUnusedMotifs(){ unusedMotifs = motifsData.slice(); }

    function chooseMotifNoImmediateRepeat(){
      if (unusedMotifs.length === 0) initUnusedMotifs();
      const idx = Math.floor(Math.random() * unusedMotifs.length);
      const motif = unusedMotifs[idx];
      unusedMotifs.splice(idx, 1);
      return motif;
    }

    function getAllowedVerbsForMotif(noun){
      const base = motifVerbBase[noun];
      return base ? base.slice() : [];
    }

    function initUnusedVerbsForMotif(noun){
      const all = getAllowedVerbsForMotif(noun);
      unusedVerbsByMotif[noun] = shuffleArray(all);
    }

    function chooseVerbForMotif(noun){
      if (!unusedVerbsByMotif[noun] || unusedVerbsByMotif[noun].length === 0){
        initUnusedVerbsForMotif(noun);
      }
      return unusedVerbsByMotif[noun].pop();
    }

    function getCssColorForAdj(adj){
      if (!adj) return null;
      const clean = adj.toLowerCase().replace(/[.,!?:;"“”„]+$/g, "");
      switch(clean){
        case "blaue": return "var(--fk-blue)";
        case "grüne": return "var(--fk-green)";
        case "violette": return "var(--fk-violet)";
        case "orangefarbene": return "var(--fk-orange)";
        default: return null;
      }
    }

    function highlightTailColor(text, adjective){
      const cssColor = getCssColorForAdj(adjective);
      const safe = escapeHtml(text);
      if (!cssColor) return safe;

      const escapedAdj = adjective.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      const regex = new RegExp(`\\b(${escapedAdj})\\b`, "i");
      return safe.replace(regex, `<span style="color:${cssColor}; font-weight:900">$1</span>`);
    }

    function setLockedUI(locked){
      fairyBtn.classList.toggle("locked", locked);
      btnErkippt.classList.toggle("locked", locked);
      btnNicht.classList.toggle("locked", locked);
    }

    function updateScore(){
      scoreEl.textContent = String(score);
    }

    function updateEndStateIfNeeded(){
      if (attempts >= maxAttempts){
        setLockedUI(true);
        indicatorEl.textContent = "Spiel für dieses Gerät beendet.";
      }
    }

    function resetAll(){
      score = 0;
      attempts = 0;

      currentMotif = null;
      currentVerb = null;
      currentColor = null;

      chunks = [];
      chunkIndex = 0;

      fairyBtn.textContent = "FAIRY";
      storyEl.classList.add("muted");
      storyEl.innerHTML = 'Tippe auf <strong>FAIRY</strong>, um eine neue Fairy zu starten.';
      indicatorEl.textContent = "";
      setLockedUI(false);
      updateScore();
    }

    // -----------------------------
    // API Key (Prompt)
    // -----------------------------
    function loadApiKey(){
      const stored = window.localStorage.getItem(APIKEY_STORAGE_KEY);
      if (stored && stored.startsWith("sk-")) {
        apiKey = stored;
        return true;
      }
      apiKey = null;
      return false;
    }

    function ensureApiKey(){
      if (apiKey && apiKey.startsWith("sk-")) return true;

      const ok = loadApiKey();
      if (ok) return true;

      const val = window.prompt("OpenAI API-Key eingeben (beginnt mit sk-):", "");
      if (!val) return false;
      const key = val.trim();
      if (!key.startsWith("sk-")) {
        alert("Ungültiger Key. Muss mit 'sk-' beginnen.");
        return false;
      }
      apiKey = key;
      window.localStorage.setItem(APIKEY_STORAGE_KEY, key);
      return true;
    }

    // -----------------------------
    // Text-Normalisierung: direkte Rede sauber + Struktur
    // -----------------------------
    function normalizeQuotes(s){
      return String(s).replace(/[„“”]/g, '"').replace(/\s+/g, " ").trim();
    }

    function forceStructure(twoSentences){
      // Ziel:
      // Satz 1 endet mit ":"  (Erzählerteil)
      // Satz 2 ist NUR direkte Rede in "..." und endet mit .?! und " (also: ...!" )
      let t = normalizeQuotes(twoSentences);

      // Grob splitten: wir nehmen erstes Satzende (.?!), Rest ist Satz2
      // Wenn KI bereits ":" verwendet, bevorzugen wir das.
      const colonIdx = t.indexOf(":");
      if (colonIdx !== -1) {
        let a = t.slice(0, colonIdx + 1).trim();
        let b = t.slice(colonIdx + 1).trim();
        // b muss direkte Rede sein
        if (!b.startsWith('"')) b = '"' + b;
        if (!/[.!?]"$/.test(b)) {
          // wenn endet auf .?! ohne "
          if (/[.!?]$/.test(b)) b = b.replace(/([.!?])$/, '$1"');
          else b = b + '!"';
        }
        return { narrator: a, speech: b };
      }

      // Kein ":" vorhanden -> wir erzwingen ":" nach Satz1
      // Suche erstes Satzzeichen .?!
      const m = t.match(/^[\s\S]*?[.!?]/);
      let s1 = "";
      let s2 = "";
      if (m) {
        s1 = m[0].trim();
        s2 = t.slice(m[0].length).trim();
      } else {
        // Fallback: alles ist s1
        s1 = t.trim();
        s2 = '"..."!"';
      }

      // s1 endet mit ":" statt .?!
      s1 = s1.replace(/[.!?]\s*$/, ":").trim();
      if (!s1.endsWith(":")) s1 += ":";

      // s2 als direkte Rede
      if (!s2.startsWith('"')) s2 = '"' + s2;
      // Wenn zweite Rede mehrere Sätze hat: wir kürzen auf letztes Satzzeichen
      const lastP = Math.max(s2.lastIndexOf("."), s2.lastIndexOf("!"), s2.lastIndexOf("?"));
      if (lastP !== -1) s2 = s2.slice(0, lastP + 1).trim();
      if (!s2.endsWith('"')) s2 = s2 + '"';
      if (!/[.!?]"$/.test(s2)) {
        if (/[.!?]$/.test(s2)) s2 = s2.replace(/([.!?])$/, '$1"');
        else s2 = s2.replace(/"$/, '!"');
      }

      return { narrator: s1, speech: s2 };
    }

    // -----------------------------
    // Nomen-Cut (Heuristik)
    // -----------------------------
    const NON_NOUNS = new Set([
      "Der","Die","Das","Ein","Eine","Einer","Eines","Einem","Einen",
      "Ich","Du","Er","Sie","Es","Wir","Ihr","Man","Wer","Was","Wo","Wie","Warum",
      "Und","Aber","Doch","Weil","Wenn","Als","Am","Im","In","Auf","Zu","Zum","Zur",
      "Jetzt","Dann","Nur","Auch","Sehr","Mehr","Noch","Schon","Bitte","Okay"
    ]);

    function isLikelyNoun(raw){
      const w = raw.replace(/^[„"“”'(\[]+|[.,!?;:)"“”'\]]+$/g, "");
      if (!w) return false;
      if (NON_NOUNS.has(w)) return false;
      // Nomen in Deutsch oft groß
      if (!/^[A-ZÄÖÜ]/.test(w)) return false;
      // nur Buchstaben/Bindestrich
      if (!/^[A-Za-zÄÖÜäöüß\-]+$/.test(w)) return false;
      // Ein-Buchstaben eher nein
      if (w.length < 2) return false;
      return true;
    }

    function splitByNouns(text){
      const tokens = text.trim().split(/\s+/).filter(Boolean);
      if (tokens.length === 0) return [];
      const parts = [];
      let buf = [];

      for (const tok of tokens){
        buf.push(tok);
        if (isLikelyNoun(tok)){
          parts.push(buf.join(" "));
          buf = [];
        }
      }
      if (buf.length) parts.push(buf.join(" "));
      return parts;
    }

    // -----------------------------
    // Chunks bauen: Erzähler + Rede (jeweils Nomen-Cuts) + Tail (1 Chunk)
    // -----------------------------
    function buildChunks(narrator, speech, verb, article, colorAdj, noun){
      const narratorCuts = splitByNouns(narrator);
      const speechCuts   = splitByNouns(speech);

      const tailPlain = `${verb} ${article} ${colorAdj} ${noun}`;
      const tailHtml  = highlightTailColor(tailPlain, colorAdj);

      const out = [];
      for (const p of narratorCuts) out.push({ html: escapeHtml(p), isHtml: true }); // safe
      for (const p of speechCuts)   out.push({ html: escapeHtml(p), isHtml: true }); // safe
      out.push({ html: tailHtml, isHtml: true, isTail: true });

      return out;
    }

    function showChunk(i){
      if (!chunks || chunks.length === 0) return;
      chunkIndex = Math.max(0, Math.min(chunks.length - 1, i));

      storyEl.classList.remove("muted");
      storyEl.innerHTML = chunks[chunkIndex].html;

      indicatorEl.innerHTML = `<strong>${chunkIndex + 1}</strong> / ${chunks.length}`;
    }

    // -----------------------------
    // OpenAI: 2 Sätze + Struktur (Satz1 ":" + Satz2 direkte Rede)
    // -----------------------------
    async function generateFairy(){
      if (attempts >= maxAttempts){
        updateEndStateIfNeeded();
        return;
      }
      if (!ensureApiKey()) return;

      const motifObj = chooseMotifNoImmediateRepeat();
      const verb = chooseVerbForMotif(motifObj.noun);
      const color = colorsData[Math.floor(Math.random() * colorsData.length)];

      currentMotif = motifObj;
      currentVerb = verb;
      currentColor = color;

      fairyBtn.textContent = "WEITER";
      storyEl.classList.add("muted");
      storyEl.textContent = "… KI schreibt eine neue Fairy …";
      indicatorEl.textContent = "";

      const systemMessage = {
        role: "system",
        content:
          "Du schreibst sehr kurze Texte auf Deutsch für ein Gesellschaftsspiel.\n" +
          "Du MUSST GENAU 2 Sätze liefern, insgesamt etwa 18–28 Wörter.\n" +
          "WICHTIG: Satz 1 endet mit einem Doppelpunkt ':'. Satz 2 ist NUR wörtliche Rede in Anführungszeichen.\n" +
          "Regeln:\n" +
          "- Schreibe in der dritten Person.\n" +
          "- Verwende keine Farbwörter.\n" +
          "- Verwende das Motivwort NICHT.\n" +
          "- Kein Genitiv.\n" +
          "- Kein 'sagte', 'meinte', 'dachte'.\n"
      };

      const userMessage = {
        role: "user",
        content:
          "Unsichtbare Hauptfigur (niemals nennen): \"" + motifObj.noun + "\".\n" +
          "Schreibe GENAU 2 Sätze (18–28 Wörter gesamt).\n" +
          "Satz 1: neutrale Situation, endet mit ':' (Doppelpunkt).\n" +
          "Satz 2: NUR direkte Rede in \"...\" und endet mit . ? oder ! (innerhalb der Anführungszeichen).\n" +
          "Nach Satz 2 darf nichts mehr kommen.\n"
      };

      try{
        const resp = await fetch(OPENAI_CHAT_URL, {
          method:"POST",
          headers:{
            "Content-Type":"application/json",
            Authorization:"Bearer " + apiKey
          },
          body: JSON.stringify({
            model: OPENAI_MODEL,
            messages: [systemMessage, userMessage],
            temperature: 0.8,
            max_tokens: 220
          })
        });

        if (!resp.ok) throw new Error("HTTP " + resp.status);

        const data = await resp.json();
        let text = data.choices?.[0]?.message?.content?.trim() || "";
        text = normalizeQuotes(text);

        // Struktur erzwingen (Erzähler ":" + direkte Rede)
        const s = forceStructure(text);

        chunks = buildChunks(s.narrator, s.speech, verb, motifObj.article, color, motifObj.noun);
        chunkIndex = 0;
        showChunk(0);

      } catch(err){
        console.error(err);
        storyEl.classList.remove("muted");
        storyEl.textContent = "Fehler beim Laden. Internet oder API-Key prüfen.";
        indicatorEl.textContent = "";
        chunks = [];
        chunkIndex = 0;
        fairyBtn.textContent = "FAIRY";
      }
    }

    // -----------------------------
    // Klicklogik
    // -----------------------------
    fairyBtn.addEventListener("click", async () => {
      if (attempts >= maxAttempts) return;

      if (!chunks || chunks.length === 0){
        await generateFairy();
        return;
      }

      if (chunkIndex < chunks.length - 1){
        showChunk(chunkIndex + 1);
      }
    });

    storyEl.addEventListener("click", () => {
      if (!chunks || chunks.length === 0) return;
      if (chunkIndex >= chunks.length - 1) return;
      showChunk(chunkIndex + 1);
    });

    // NICHT ERKIPPT: +1 Versuch, keine Punkte, Fairy darf bleiben
    btnNicht.addEventListener("click", () => {
      if (attempts >= maxAttempts) return;
      attempts += 1;
      updateEndStateIfNeeded();
    });

    // FAIRY ERKIPPT: Bestätigung
    btnErkippt.addEventListener("click", () => {
      if (attempts >= maxAttempts) return;
      confirmOverlay.style.display = "flex";
    });

    // ✓: +1 Punkt +1 Versuch, Fairy weg -> bereit für nächste
    confirmOk.addEventListener("click", () => {
      confirmOverlay.style.display = "none";
      if (attempts >= maxAttempts) return;

      attempts += 1;
      score += 1;
      updateScore();

      // Fairy “verbraucht”
      currentMotif = null;
      currentVerb = null;
      currentColor = null;

      chunks = [];
      chunkIndex = 0;

      fairyBtn.textContent = "FAIRY";
      storyEl.classList.add("muted");
      storyEl.innerHTML = 'Tippe auf <strong>FAIRY</strong>, um die nächste Fairy zu starten.';
      indicatorEl.textContent = "";

      updateEndStateIfNeeded();
    });

    // ✕: Abbruch
    confirmNo.addEventListener("click", () => {
      confirmOverlay.style.display = "none";
    });

    // Neues Spiel
    newgameBtn.addEventListener("click", () => resetAll());

    // Zur Startseite => index.html
    homeBtn.addEventListener("click", () => {
      // Wenn deine Hauptseite index.html ist:
      window.location.href = "index.html";
    });

    // Start
    (function init(){
      loadApiKey();
      initUnusedMotifs();
      updateScore();
      resetAll();
    })();
  </script>
</body>
</html>
